#!/bin/bash

set -euo pipefail

function log {
  echo >&2 "[smart-pull]" "$@"
}

set +e
if [ "$(tput colors 2>/dev/null)" -ge 8 ]; then
  function log {
    printf >&2 "\033[90m"
    echo   >&2 "[smart-pull]" "$@"
    printf >&2 "\033[0m"
  }
fi
set -e

log "Attempting fast-forward pull"
set +e
git pull --ff-only "$@" 2>/dev/null
res=$?
set -e

if [ $res -eq 0 ]; then
  log "Fast-forward pull succeeded."
  exit 0
elif [ $res -ne 128 ]; then
  log "git pull exited with unexpected status $res"
  log "Re-running it so you can see the output:"
  git pull --ff-only "$@"
fi

log "Fast-forward pull failed."
log "Checking if we can rebase without conflict."
if ! git diff --quiet --ignore-submodules || ! git diff --staged --quiet; then
  log "Dirty working tree or index. Aborting."
  exit 2
fi
upstream_branch="$(git rev-parse --abbrev-ref --symbolic-full-name "@{u}")"
git branch -D _git-smart-pull --quiet 2>/dev/null || true
git checkout -b _git-smart-pull --quiet
git branch --set-upstream-to "$upstream_branch" --quiet
set +e
git pull --rebase=true >/dev/null 2>/dev/null
rebase_ok=$?
set -e
if [ $rebase_ok -eq 0 ]; then
  log "Can rebase without conflict."
  log "Will pull with rebase."
  git checkout -
  git branch -D _git-smart-pull --quiet 2>/dev/null || true
  git pull --rebase=true
else
  log "Cannot rebase without conflict. Conflicted files:"
  ( 
    IFS=$'\n'
    for f in $(git diff --name-only --diff-filter=U --relative); do
      log "$f"
    done
  )
  git rebase --abort
  git checkout - --quiet
  git branch -D _git-smart-pull --quiet 2>/dev/null || true
  while true; do
    read -r -p "Select pull method: [m]erge / [r]ebase / [q]uit " res
    case $res in
      m)
        exec git pull --rebase=no
        break
        ;;
      r)
        upstream="$(git rev-parse --abbrev-ref "@{u}")"
        merge_base="$(git merge-base HEAD "$upstream")"
        if [ "$(git rev-list --count "$merge_base"..)" -gt 1 ]; then
          echo >&2 "Commits to be rebased:"
          git log --oneline "$merge_base"..
          while true; do
            read -r -p "Do you want to squash the commits before rebasing? [s]quash / [i]nteractive rebase / [n]o " res
            case $res in
              s)
                first_commit_after_merge_base="$(git rev-list --reverse "$merge_base".. | head -n 1)"
                git reset --soft "$first_commit_after_merge_base"
                git add -A
                git commit --amend
                break
                ;;
              i)
                git rebase -i "$merge_base"
                break
                ;;
              n)
                break
                ;;
              *) ;;
          esac
        done
      fi
        exec git pull --rebase=yes
        break
        ;;
      q)
        exit 1
        ;;
      *) ;;
    esac
  done
fi
